// Code generated by mockery v2.16.0. DO NOT EDIT.

package mocks

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	entities "github.com/sumup/sii-certification/internal/entities"
)

// IRepository is an autogenerated mock type for the IRepository type
type IRepository struct {
	mock.Mock
}

// CountBatchesGroupByDay provides a mock function with given fields: ctx, startDate, endDate
func (_m *IRepository) CountBatchesGroupByDay(ctx context.Context, startDate string, endDate string) (int64, error) {
	ret := _m.Called(ctx, startDate, endDate)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string, string) int64); ok {
		r0 = rf(ctx, startDate, endDate)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, startDate, endDate)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountByDay provides a mock function with given fields: ctx, day
func (_m *IRepository) CountByDay(ctx context.Context, day string) (int64, error) {
	ret := _m.Called(ctx, day)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, string) int64); ok {
		r0 = rf(ctx, day)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, day)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMany provides a mock function with given fields: ctx, startDate, endDate, statuses, page, pageSize
func (_m *IRepository) FindMany(ctx context.Context, startDate string, endDate string, statuses []int, page int, pageSize int) ([]entities.Batch, error) {
	ret := _m.Called(ctx, startDate, endDate, statuses, page, pageSize)

	var r0 []entities.Batch
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []int, int, int) []entities.Batch); ok {
		r0 = rf(ctx, startDate, endDate, statuses, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entities.Batch)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, []int, int, int) error); ok {
		r1 = rf(ctx, startDate, endDate, statuses, page, pageSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertMany provides a mock function with given fields: ctx, _a1
func (_m *IRepository) InsertMany(ctx context.Context, _a1 []entities.Batch) ([]entities.Batch, error) {
	ret := _m.Called(ctx, _a1)

	var r0 []entities.Batch
	if rf, ok := ret.Get(0).(func(context.Context, []entities.Batch) []entities.Batch); ok {
		r0 = rf(ctx, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entities.Batch)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []entities.Batch) error); ok {
		r1 = rf(ctx, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StatusesOfDay provides a mock function with given fields: ctx, startDate, endDate, page, pageSize
func (_m *IRepository) StatusesOfDay(ctx context.Context, startDate string, endDate string, page int, pageSize int) ([]entities.StatusesOfDay, error) {
	ret := _m.Called(ctx, startDate, endDate, page, pageSize)

	var r0 []entities.StatusesOfDay
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, int) []entities.StatusesOfDay); ok {
		r0 = rf(ctx, startDate, endDate, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entities.StatusesOfDay)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, int, int) error); ok {
		r1 = rf(ctx, startDate, endDate, page, pageSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateManyStatus provides a mock function with given fields: ctx, _a1, status, lastResponse
func (_m *IRepository) UpdateManyStatus(ctx context.Context, _a1 []entities.Batch, status int, lastResponse string) {
	_m.Called(ctx, _a1, status, lastResponse)
}

// UpdateOne provides a mock function with given fields: ctx, batchToUpdate
func (_m *IRepository) UpdateOne(ctx context.Context, batchToUpdate entities.Batch) {
	_m.Called(ctx, batchToUpdate)
}

type mockConstructorTestingTNewIRepository interface {
	mock.TestingT
	Cleanup(func())
}

// NewIRepository creates a new instance of IRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewIRepository(t mockConstructorTestingTNewIRepository) *IRepository {
	mock := &IRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
